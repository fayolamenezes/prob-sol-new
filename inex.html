<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hover Band with Dotted Strip + Smooth Bulge</title>
<style>
body {
  margin:0;
  background:black;
  display:flex;
  align-items:center;
  justify-content:center;
  height:100vh;
  overflow:hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

<!-- Vertex Shader -->
<script id="vertexShader" type="x-shader/x-vertex">
uniform vec2 uMouse;
uniform float uHover;
uniform float uBulgeHeight;    
uniform float uBulgeRadiusX;   
uniform float uBulgeRadiusY;   

varying vec2 vUv;

void main(){
  vUv = uv;
  vec3 newPosition = position;

  vec2 offset = uv - uMouse;

  // Gaussian-style falloff
  vec2 scaledOffset = vec2(offset.x / uBulgeRadiusX, offset.y / uBulgeRadiusY);
  float dist = dot(scaledOffset, scaledOffset); 
  float bulgeFalloff = exp(-dist * 4.0); 

  // Stronger edge fade: fade starts at margin, completely gone at edges
  float margin = 0.1; // how far from edges the bulge starts fading
  float edgeX = smoothstep(0.0, margin, uv.x) * smoothstep(0.0, margin, 1.0 - uv.x);
  float edgeY = smoothstep(0.0, margin, uv.y) * smoothstep(0.0, margin, 1.0 - uv.y);
  float edgeMask = pow(edgeX * edgeY, 3.0); // sharpen the fade

  float bulge = uBulgeHeight * bulgeFalloff * uHover * edgeMask;
  newPosition.z += bulge;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0);
}
</script>

<!-- Fragment Shader -->
<script id="fragmentShader" type="x-shader/x-fragment">
uniform vec2 uMouse;
uniform float uHover;

varying vec2 vUv;

float square(vec2 st, float size){
  vec2 dist = abs(st - floor(st) - 0.5);
  return step(dist.x, size) * step(dist.y, size);
}

void main(){
  if(vUv.x<0.0||vUv.x>1.0||vUv.y<0.0||vUv.y>1.0) discard;

  vec3 baseColor = vec3(0.0);
  vec3 glowColor = vec3(0.85,0.35,0.15);

  float vDist = abs(vUv.y - uMouse.y);
  float stripFalloff = smoothstep(0.9,0.0,vDist); 
  float stripMask = stripFalloff * uHover;

  vec2 st = vUv * 55.0;            
  float squareMask = square(st, 0.18); 
  float dotPattern = 1.0 - squareMask;

  float baseIntensity = 0.25 * stripMask;
  vec3 stripColor = glowColor * baseIntensity;
  stripColor *= dotPattern;

  vec2 scaledOffset = (vUv - uMouse) / vec2(0.4,0.25);
  float dist = dot(scaledOffset, scaledOffset);
  float bulgeBoost = exp(-dist * 2.0) * uHover * 0.6; 

  stripColor += glowColor * bulgeBoost * (0.5 + 0.5 * dotPattern);

  vec3 color = baseColor + stripColor;
  gl_FragColor = vec4(color,1.0);
}
</script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,0.1,100);
camera.position.z = 2;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

const uniforms = {
  uMouse:{value:new THREE.Vector2(0.5,0.5)},
  uHover:{value:0.0},
  uBulgeHeight:{value:0.4},   
  uBulgeRadiusX:{value:0.4},  
  uBulgeRadiusY:{value:0.25}
};

// --- Card ---
const cardWidth = 1.7;
const cardHeight = 0.8;
const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight, 150, 200);
const material = new THREE.ShaderMaterial({
  vertexShader: document.getElementById("vertexShader").textContent,
  fragmentShader: document.getElementById("fragmentShader").textContent,
  uniforms,
  side: THREE.DoubleSide
});
const card = new THREE.Mesh(geometry,material);
scene.add(card);

// --- Border ---
const borderEdges = new THREE.EdgesGeometry(new THREE.PlaneGeometry(cardWidth, cardHeight));
const borderMaterial = new THREE.LineBasicMaterial({ color: 0x555555, linewidth: 1 });
const border = new THREE.LineSegments(borderEdges, borderMaterial);
scene.add(border);

card.position.z = 0.001;

// --- Hover logic ---
let isHovering=false;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

document.addEventListener("mousemove",(e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;

  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObject(card);
  if(intersects.length>0){
    isHovering = true;
    const uv = intersects[0].uv;
    uniforms.uMouse.value.copy(uv);
  }else{
    isHovering = false;
  }
});

// --- Animation loop ---
function animate(){
  requestAnimationFrame(animate);
  uniforms.uHover.value = THREE.MathUtils.lerp(uniforms.uHover.value,isHovering?1.0:0.0,0.1);
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
