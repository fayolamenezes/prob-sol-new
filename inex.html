<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hover Band with Dotted Strip + Smooth Bulge</title>
<style>
body {
  margin:0;
  background:black;
  display:flex;
  align-items:center;
  justify-content:center;
  height:100vh;
  overflow:hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

<!-- Vertex Shader -->
<script id="vertexShader" type="x-shader/x-vertex">
uniform vec2 uMouse;
uniform float uHover;
uniform float uBulgeHeight;    
uniform float uBulgeRadiusX;   
uniform float uBulgeRadiusY;   

varying vec2 vUv;

void main(){
  vUv = uv;
  vec3 newPosition = position;

  vec2 offset = uv - uMouse;

  // Gaussian-style soft falloff for geometry displacement
  vec2 scaledOffset = vec2(offset.x / uBulgeRadiusX, offset.y / uBulgeRadiusY);
  float dist = dot(scaledOffset, scaledOffset); 
  float bulgeFalloff = exp(-dist * 4.0); 

  float bulge = uBulgeHeight * bulgeFalloff * uHover;
  newPosition.z += bulge;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0);
}
</script>

<!-- Fragment Shader -->
<script id="fragmentShader" type="x-shader/x-fragment">
uniform vec2 uMouse;
uniform float uHover;

varying vec2 vUv;

float square(vec2 st, float size){
  vec2 dist = abs(st - floor(st) - 0.5);
  return step(dist.x, size) * step(dist.y, size);
}

void main(){
  if(vUv.x<0.0||vUv.x>1.0||vUv.y<0.0||vUv.y>1.0) discard;

  vec3 baseColor = vec3(0.0);
  vec3 glowColor = vec3(0.85,0.35,0.15);

  // --- Horizontal strip intensity (only visible on hover) ---
  float vDist = abs(vUv.y - uMouse.y);
  float stripFalloff = smoothstep(0.45,0.0,vDist); 
  float stripMask = stripFalloff * uHover;

  // Square pattern across strip
  vec2 st = vUv * 50.0;             // controls spacing
  float squareMask = square(st, 0.15); // controls size
  float dotPattern = 1.0 - squareMask;

  // Base strip color
  float baseIntensity = 0.25 * stripMask;
  vec3 stripColor = glowColor * baseIntensity;

  // Apply square mask to strip
  stripColor *= dotPattern;

  // --- Bulge boost near mouse ---
  vec2 scaledOffset = (vUv - uMouse) / vec2(0.4,0.25);
  float dist = dot(scaledOffset, scaledOffset);

  float bulgeBoost = exp(-dist * 2.0) * uHover * 0.6; 

  stripColor += glowColor * bulgeBoost * (0.5 + 0.5 * dotPattern);

  vec3 color = baseColor + stripColor;
  gl_FragColor = vec4(color,1.0);
}
</script>


<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,0.1,100);
camera.position.z = 2;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

const uniforms = {
  uMouse:{value:new THREE.Vector2(0.5,0.5)},
  uHover:{value:0.0},
  uBulgeHeight:{value:0.4},   
  uBulgeRadiusX:{value:0.4},  
  uBulgeRadiusY:{value:0.25} 
};

const geometry = new THREE.PlaneGeometry(1,1.5,150,200);
const material = new THREE.ShaderMaterial({
  vertexShader: document.getElementById("vertexShader").textContent,
  fragmentShader: document.getElementById("fragmentShader").textContent,
  uniforms,
  side: THREE.DoubleSide
});

const card = new THREE.Mesh(geometry,material);
scene.add(card);

// Border
const borderGeometry = new THREE.PlaneGeometry(1.02,1.52);
const borderMaterial = new THREE.MeshBasicMaterial({color:0x555555,side:THREE.DoubleSide});
const border = new THREE.Mesh(borderGeometry,borderMaterial);
scene.add(border);
card.position.z = 0.001;

let isHovering=false;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

document.addEventListener("mousemove",(e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;

  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObject(card);
  if(intersects.length>0){
    isHovering = true;
    uniforms.uMouse.value.copy(intersects[0].uv);
  }else{
    isHovering = false;
  }
});

function animate(){
  requestAnimationFrame(animate);
  uniforms.uHover.value = THREE.MathUtils.lerp(uniforms.uHover.value,isHovering?1.0:0.0,0.1);
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
